{"version":3,"sources":["matteodem:easy-security/lib/easy-security.js","matteodem:easy-security/lib/server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,6B;AACA,e;;AAEA,mB;;AAEA,uB;AACA,8C;AACA,gB;AACA,kB;AACA,gC;AACA,yB;AACA,I;;AAEA,2D;;AAEA,oB;;AAEA,wB;AACA,0C;AACA,+B;AACA,kB;AACA,4B;AACA,2C;AACA,6C;AACA,G;AACA,E;AACA,oC;AACA,qD;AACA,gE;AACA,4C;AACA,uB;AACA,I;;AAEA,K;AACA,qB;AACA,K;AACA,+B;AACA,gC;AACA,gC;AACA,K;;AAEA,8D;AACA,mC;AACA,qB;AACA,G;;AAEA,kC;AACA,gD;;AAEA,wB;AACA,yE;AACA,kB;;AAEA,6D;AACA,2C;AACA,U;;AAEA,wB;AACA,gF;AACA,O;;AAEA,8C;;AAEA,mD;AACA,8B;AACA,O;;AAEA,uB;AACA,M;AACA,G;;AAEA,K;AACA,qB;AACA,K;AACA,uB;AACA,a;AACA,0E;AACA,M;AACA,oD;AACA,4C;AACA,6B;AACA,iB;;AAEA,wD;AACA,uC;AACA,O;;AAEA,iB;AACA,gC;;AAEA,8D;AACA,a;AACA,uE;AACA,qB;AACA,2D;AACA,S;;AAEA,c;AACA,qC;AACA,O;AACA,M;AACA,wC;AACA,+B;AACA,wC;;AAEA,qB;AACA,oC;AACA,O;;AAEA,8C;AACA,2C;AACA,+B;AACA,mB;AACA,0C;AACA,iB;AACA,S;AACA,O;;AAEA,0B;AACA,qC;AACA,gC;AACA,2B;AACA,2B;;AAEA,sC;AACA,wD;AACA,S;;AAEA,sD;AACA,oD;;AAEA,4C;AACA,8C;AACA,0D;;AAEA,uC;AACA,4D;AACA,qB;AACA,S;;AAEA,6B;AACA,Q;AACA,K;AACA,I;;AAEA,mF;;AAEA,K;AACA,oB;AACA,K;AACA,sB;AACA,a;AACA,oD;AACA,M;AACA,oD;AACA,yC;AACA,6B;;AAEA,0B;AACA,qC;AACA,qC;AACA,iC;;AAEA,sC;AACA,oE;AACA,S;;AAEA,0B;AACA,kF;AACA,S;;AAEA,yG;AACA,iD;;AAEA,oD;AACA,iF;AACA,2C;;AAEA,kD;AACA,S;;AAEA,oB;AACA,Q;AACA,K;AACA,I;;AAEA,K;AACA,oB;AACA,K;AACA,kB;AACA,a;AACA,oD;AACA,M;AACA,4C;AACA,iC;AACA,6B;;AAEA,0B;AACA,qC;AACA,iC;AACA,2B;;AAEA,sC;AACA,+D;AACA,S;;AAEA,0B;AACA,6E;AACA,S;;AAEA,6C;AACA,8D;AACA,S;;AAEA,wE;AACA,iD;AACA,iF;AACA,2C;AACA,gD;AACA,sC;AACA,e;;AAEA,oB;AACA,Q;AACA,K;AACA,I;;AAEA,U;AACA,4B;AACA,oC;AACA,sC;AACA,sB;AACA,+B;AACA,6F;AACA,O;AACA,M;AACA,kC;AACA,uB;AACA,6B;AACA,O;;AAEA,iF;AACA,iF;AACA,qG;AACA,2C;AACA,M;AACA,oC;AACA,uC;AACA,uC;AACA,O;;AAEA,2C;AACA,M;AACA,sC;AACA,6B;;AAEA,qC;AACA,wC;AACA,S;AACA,M;AACA,+B;AACA,6C;AACA,M;AACA,iC;AACA,qC;AACA,M;AACA,gC;AACA,2B;AACA,uE;AACA,O;;AAEA,2B;AACA,M;AACA,+C;AACA,uC;;AAEA,wC;AACA,2C;AACA,O;;AAEA,4D;AACA,oB;AACA,O;;AAEA,4E;AACA,M;AACA,iB;AACA,I;AACA,K;;;;;;;;;;;;;;;;;;;AChSA,qB;AACA,a;;AAEA,oD;AACA,qE;;AAEA,wE;AACA,uC;AACA,M;AACA,Q;;AAEA,4C;AACA,yC;AACA,G;;AAEA,yC;AACA,uE;AACA,qC;AACA,qC;AACA,G;;AAEA,wD;;AAEA,oC;AACA,sC;;AAEA,oE;AACA,6C;;AAEA,qC;AACA,kF;AACA,+F;AACA,sF;AACA,6C;AACA,qB;AACA,2B;AACA,c;AACA,2B;AACA,O;AACA,K;AACA,K;;AAEA,kC;AACA,6D;AACA,K;AACA,G;;AAEA,4B;AACA,e;;AAEA,gC;;AAEA,iC;AACA,a;;AAEA,6D;AACA,2E;AACA,K;;AAEA,mB;AACA,G;;AAEA,wD;AACA,wC;AACA,gC;AACA,uC;AACA,G;;AAEA,4D;AACA,6E;;AAEA,uC;AACA,wD;AACA,I;AACA,G","file":"/packages/matteodem:easy-security.js","sourcesContent":["EasySecurity = (function () {\n  'use strict';\n\n  var methods = {};\n\n  var configuration = {\n      general: { type: 'rateLimit', ms: 500 },\n      hooks: {},\n      methods: {},\n      ignoredMethods: ['login'],\n      maxQueueLength: 100\n  };\n\n  configuration._defaults = _.clone(configuration.general);\n\n  var Future = null;\n\n  if (Meteor.isServer) {\n    Future = Npm.require('fibers/future');\n  } else if (Meteor.isClient) {\n    // Future Fake\n    Future = function () {};\n    Future.prototype.wait = function () {};\n    Future.prototype.return = function () {};\n  }\n  \n  // Easy Security Error Constructor\n  // This allows to check object for it's inheritance\n  // without having to set any custom properties to check for it\n  var EasySecurityError = function (error) {\n    this.error = error;\n  };\n\n  /**\n   * Helper Functions\n   */\n  function getId(scope, rand) {\n    if (scope && scope.userId) {\n      var userId = scope.userId;\n    }\n\n    if (scope && scope.connection) return scope.connection.id;\n    else if (userId) return userId;\n    else return rand;\n  }\n\n  function wrapHooks(name, func) {\n    var hooks = configuration.hooks[name] || [];\n\n    return function () {\n      var funcScope = this, args = Array.prototype.slice.call(arguments),\n        returnVal;\n\n      var canExecute = _.every(_.map(hooks, function (hook) {\n        return hook.apply(funcScope, args);\n      }));\n\n      if (!canExecute) {\n        throw new Meteor.Error(\"Hook stopped \" + name + \" from being executed\");\n      }\n\n      returnVal = func.apply(this, arguments);\n\n      if (returnVal instanceof EasySecurityError) {\n        throw returnVal.error;\n      }\n\n      return returnVal;\n    };\n  }\n\n  /**\n   * RateLimit Method\n   */\n  methods.rateLimit = {\n    queues: {\n      // 'someId' : { functions: [func, func, func, func...], timer: ... }\n    },\n    callFunctionsInQueue: function (id, funcScope) {\n      var funcs = this.queues[id].functions,\n        func = funcs.shift(),\n        funcData;\n\n      if (funcs.length > configuration.maxQueueLength) {\n        this.queues[id].functions = [];\n      }\n\n      if (func) {\n        funcData = func._esData;\n\n        // try to get the return value, otherwise catch errors\n        try {\n          funcData.future.return(func.apply(funcScope, funcData.args));\n        } catch (e) {\n          funcData.future.return(new EasySecurityError(e));\n        }\n\n      } else {\n        this.queues[id].timer = null;\n      }\n    },\n    wrap: function (func, ms, timeout) {\n      var random = Random.id(),\n        methodScope = methods.rateLimit;\n\n      if (!timeout) {\n        timeout = Meteor.setTimeout;\n      }\n\n      function timeoutFunction(func, ms, id) {\n        if (methodScope.queues[id].timer) {\n          timeout(function () {\n            func();\n            timeoutFunction(func, ms, id);\n          }, ms);\n        }\n      }\n\n      return function () {\n        var id = getId(this, random),\n          future = new Future(),\n          funcScope = this,\n          args = arguments;\n\n        if (!methodScope.queues[id]) {\n          methodScope.queues[id] = { 'functions' : [] };\n        }\n\n        func._esData = { args: args, future: future };\n        methodScope.queues[id].functions.push(func);\n\n        if (!methodScope.queues[id].timer) {\n          methodScope.queues[id].timer = true;\n          methodScope.callFunctionsInQueue(id, funcScope);\n\n          timeoutFunction(function () {\n            methodScope.callFunctionsInQueue(id, funcScope);\n          }, ms, id);\n        }\n\n        return future.wait();\n      };\n    }\n  };\n\n  // inspiration from http://blogorama.nerdworks.in/javascriptfunctionthrottlingan/\n\n  /**\n   * Throttle Method\n   */\n  methods.throttle = {\n    queues: {\n      // 'someId' : { data: [], previousCall: time }\n    },\n    wrap: function throttle(func, ms, collectData) {\n      var methodScope = methods.throttle,\n        random = Random.id();\n\n      return function () {\n        var id = getId(this, random),\n          now = new Date().getTime(),\n          funcScope = this || {};\n\n        if (!methodScope.queues[id]) {\n          methodScope.queues[id] = { data: [], previousCall: null };\n        }\n\n        if (collectData) {\n          methodScope.queues[id].data.push(Array.prototype.slice.call(arguments));\n        }\n\n        if (!methodScope.queues[id].previousCall || (now  - methodScope.queues[id].previousCall) >= ms) {\n          var data = methodScope.queues[id].data;\n\n          methodScope.queues[id].previousCall = now;\n          funcScope.collectedData = collectData ? { data: _.clone(data) } : null;\n          methodScope.queues[id].data = [];\n\n          return func.apply(funcScope, arguments);\n        }\n\n        return null;\n      };\n    }\n  };\n\n  /**\n   * Debounce Method\n   */\n  var debounce = {\n    queues: {\n      // 'someId' : { data: [], previousCall: time }\n    },\n    wrap: function (func, ms, collectData) {\n      var methodScope = debounce,\n        random = Random.id();\n\n      return function () {\n        var id = getId(this, random),\n          funcScope = this || {},\n          args = arguments;\n\n        if (!methodScope.queues[id]) {\n          methodScope.queues[id] = { data: [], timeout: null };\n        }\n\n        if (collectData) {\n          methodScope.queues[id].data.push(Array.prototype.slice.call(args));\n        }\n\n        if (methodScope.queues[id].timeout) {\n          Meteor.clearTimeout(methodScope.queues[id].timeout);\n        }\n\n        methodScope.queues[id].timeout = Meteor.setTimeout(function () {\n          var data = methodScope.queues[id].data;\n          funcScope.collectedData = collectData ? _.clone({ data: data }) : null;\n          methodScope.queues[id].data = [];\n          methodScope.queues[id].timeout = null;\n          func.apply(funcScope, args);\n        }, ms);\n\n        return null;\n      };\n    }\n  };\n\n  return {\n    debounce: debounce.wrap,\n    throttle: methods.throttle.wrap,\n    rateLimit: methods.rateLimit.wrap,\n    log: function () {\n      if (EasySecurity.DEBUG) {\n        console.log('EasySecurity LOG: ' + Array.prototype.slice.call(arguments).join(', '));\n      }\n    },\n    config: function (newConfig) {\n      if (!newConfig) {\n        return configuration;\n      }\n\n      configuration.general = _.extend(configuration.general, newConfig.general);\n      configuration.methods = _.extend(configuration.methods, newConfig.methods);\n      configuration.ignoredMethods = _.union(configuration.ignoredMethods, newConfig.ignoredMethods);\n      EasySecurity.DEBUG = newConfig.debug;\n    },\n    addHook: function (name, func) {\n      if (!configuration.hooks[name]) {\n        configuration.hooks[name] = [];\n      }\n\n      configuration.hooks[name].push(func);\n    },\n    addHooks: function (names, func) {\n      var publicScope = this;\n\n      _.each(names, function (name) {\n        publicScope.addHook(name, func);\n      });\n    },\n    getHooks: function (name) {\n      return configuration.hooks[name] || [];\n    },\n    resetHooks: function (name) {\n      configuration.hooks[name] = [];\n    },\n    getMethod: function (name) {\n      if (!methods[name]) {\n        throw new Meteor.Error('Method: ' + name + ' does not exist!');\n      }\n\n      return methods[name];\n    },\n    getSecuredFunction: function (name, func) {\n      var conf = configuration.general;\n\n      if (configuration.methods[name]) {\n        conf = configuration.methods[name];\n      }\n\n      if (configuration.ignoredMethods.indexOf(name) > -1) {\n        return func;\n      }\n\n      return wrapHooks(name, this.getMethod(conf.type).wrap(func, conf.ms));\n    },\n    _getId: getId\n  };\n})();\n","var connections = {},\n  calls = {};\n\nvar rateLimit = EasySecurity.rateLimit(function () {\n  var funcScope = this, args = Array.prototype.slice.call(arguments);\n\n  return _.every(_.map(EasySecurity.getHooks('login'), function (hook) {\n    return hook.apply(funcScope, args);\n  }));\n}, 500);\n\nMeteor.server.onConnection(function (conn) {\n  connections[conn.clientAddress] = conn;\n});\n\n// Hook into the raw ddp calls being sent\nMeteor.server.stream_server.server.on('connection', function (socket) {\n  if (!calls[socket.remoteAddress]) {\n    calls[socket.remoteAddress] = [];\n  }\n\n  EasySecurity.log(socket.remoteAddress + ' connected');\n\n  socket.on('data', function (raw) {\n    var ipAddr = socket.remoteAddress;\n\n    calls[ipAddr].push({ time: (new Date()).getTime(), data: raw });\n    EasySecurity.log(ipAddr + ' sent '+ raw);\n\n    if (calls[ipAddr].length > 100) {\n      // More than 100 times data received in the past 5 seconds, close the socket\n      if ((calls[ipAddr][calls[ipAddr].length - 1].time  - calls[ipAddr][0].time) < 1000 * 5) {\n        EasySecurity.log(ipAddr + ' sent data over 100 times in the past 5 seconds!');\n        EasySecurity.log('Closing session!');\n        socket.end();\n        calls[ipAddr] = [];\n      } else {\n        calls[ipAddr] = [];\n      }\n    }\n  });\n\n  socket.on('close', function () {\n    EasySecurity.log(socket.remoteAddress + ' disconnected');\n  });\n});\n\nMeteor.startup(function () {\n  'use strict';\n\n  var _methods = Meteor.methods;\n\n  function wrapMethods(methods) {\n    var name;\n\n    for (name in methods) if (methods.hasOwnProperty(name)) {\n      methods[name] = EasySecurity.getSecuredFunction(name, methods[name]);\n    }\n\n    return methods;\n  }\n\n  // Login hooks, needs to be handled with its own hooks\n  if (typeof Accounts !== \"undefined\") {\n    Accounts.onLogin(rateLimit);\n    Accounts.onLoginFailure(rateLimit);\n  }\n\n  // Rewrite current registered methods and methods function\n  Meteor.server.method_handlers = wrapMethods(Meteor.server.method_handlers);\n\n  Meteor.methods = function (methods) {\n    return _methods.apply(this, [wrapMethods(methods)]);\n  };\n});\n"]}